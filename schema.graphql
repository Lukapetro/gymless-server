### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  token: String!
  user: User!
}

type Card {
  brand: String!
}

type Cordinates {
  address: String
  city: String
  id: Int!
  latitude: Float
  longitude: Float
  workout(skip: Int): [Workout!]!
}

input CordinatesCreateInput {
  address: String
  city: String
  latitude: Float
  longitude: Float
  workout: WorkoutCreateManyWithoutCordinatesInput
}

input CordinatesCreateOneWithoutWorkoutInput {
  connect: CordinatesWhereUniqueInput
  create: CordinatesCreateWithoutWorkoutInput
}

input CordinatesCreateWithoutWorkoutInput {
  address: String
  city: String
  latitude: Float
  longitude: Float
}

input CordinatesUpdateInput {
  address: String
  city: String
  latitude: Float
  longitude: Float
  workout: WorkoutUpdateManyWithoutCordinatesInput
}

input CordinatesUpdateOneRequiredWithoutWorkoutInput {
  connect: CordinatesWhereUniqueInput
  create: CordinatesCreateWithoutWorkoutInput
  update: CordinatesUpdateWithoutWorkoutDataInput
  upsert: CordinatesUpsertWithoutWorkoutInput
}

input CordinatesUpdateWithoutWorkoutDataInput {
  address: String
  city: String
  latitude: Float
  longitude: Float
}

input CordinatesUpsertWithoutWorkoutInput {
  create: CordinatesCreateWithoutWorkoutInput!
  update: CordinatesUpdateWithoutWorkoutDataInput!
}

input CordinatesWhereInput {
  address: NullableStringFilter
  AND: [CordinatesWhereInput!]
  city: NullableStringFilter
  id: IntFilter
  latitude: NullableFloatFilter
  longitude: NullableFloatFilter
  NOT: [CordinatesWhereInput!]
  OR: [CordinatesWhereInput!]
  workout: WorkoutFilter
}

input CordinatesWhereUniqueInput {
  id: Int
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

scalar JSON

type Mutation {
  bookClass(id: Int!): Workout!
  createOneCordinates(data: CordinatesCreateInput!): Cordinates!
  createWorkout(cordinatesId: Int, date: DateTime, description: String, duration: Int!, price: Int!, spots: Int!, title: String!): Workout!
  deleteBooking(id: ID): Workout!
  deleteOneCordinates(where: CordinatesWhereUniqueInput!): Cordinates
  deleteOneWorkout(where: WorkoutWhereUniqueInput!): Workout
  deleteUser: User!
  detachPaymentMethod(id: String!): JSON!
  facebookConnect(fbToken: String!): User!
  facebookDisconnect: User!
  facebookLogin(fbToken: String!): AuthPayload!
  login(email: String!, password: String!): AuthPayload!
  paymentIntent(amount: Int!, id: Int!, paymentMethod: String!): Workout!
  setupIntent: String!
  signup(email: String!, name: String, password: String!): AuthPayload!
  trainerLogin(email: String!, password: String!): AuthPayload!
  updateAvatar(avatarId: String): User!
  updateOneCordinates(data: CordinatesUpdateInput!, where: CordinatesWhereUniqueInput!): Cordinates
  updateOneWorkout(data: WorkoutUpdateInput!, where: WorkoutWhereUniqueInput!): Workout
  updateUser(birthDate: Date, email: String, name: String, sex: Sex): User!
  updateUserClasses(classes: Int!): User!
  updateUserPassword(newPassword: String, oldPassword: String): User!
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: Float
  notIn: [Float!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type PaymentMethods {
  data: [Card!]!
}

type Query {
  cordinates(skip: Int): [Cordinates!]!
  futureWorkouts: [Workout!]!
  me: User!
  pastWorkouts: [Workout!]!
  paymentMethods: JSON!
  userAvailableWorkouts: [Workout!]!
  workout(where: WorkoutWhereUniqueInput!): Workout
  workouts(skip: Int, where: WorkoutWhereInput): [Workout!]!
  workoutsBooked: [Workout!]!
}

enum Role {
  admin
  trainer
  user
}

"""The sex of the user"""
enum Sex {
  female
  male
  unknown
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  avatarId: String
  bio: String
  birthDate: DateTime
  classes: Int!
  customerId: String
  email: String!
  facebookId: String
  id: Int!
  name: String
  role: Role!
  sex: Sex!
  stripeId: String
  workouts(skip: Int): [Workout!]!
}

input UserCreateManyWithoutWorkoutsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutWorkoutsInput!]
}

input UserCreateOneWithoutTrainInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTrainInput
}

input UserCreateWithoutTrainInput {
  avatarId: String
  bio: String
  birthDate: DateTime
  classes: Int
  customerId: String
  email: String!
  facebookId: String
  name: String
  password: String!
  role: Role
  sex: Sex
  stripeId: String
  workouts: WorkoutCreateManyWithoutPartecipantsInput
}

input UserCreateWithoutWorkoutsInput {
  avatarId: String
  bio: String
  birthDate: DateTime
  classes: Int
  customerId: String
  email: String!
  facebookId: String
  name: String
  password: String!
  role: Role
  sex: Sex
  stripeId: String
  train: WorkoutCreateManyWithoutTrainerInput
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  avatarId: NullableStringFilter
  bio: NullableStringFilter
  birthDate: NullableDateTimeFilter
  classes: IntFilter
  customerId: NullableStringFilter
  email: StringFilter
  facebookId: NullableStringFilter
  id: IntFilter
  name: NullableStringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
  role: Role
  sex: Sex
  stripeId: NullableStringFilter
  train: WorkoutFilter
  workouts: WorkoutFilter
}

input UserUpdateManyDataInput {
  avatarId: String
  bio: String
  birthDate: DateTime
  classes: Int
  customerId: String
  email: String
  facebookId: String
  name: String
  password: String
  role: Role
  sex: Sex
  stripeId: String
}

input UserUpdateManyWithoutWorkoutsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutWorkoutsInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutWorkoutsInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutWorkoutsInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateOneRequiredWithoutTrainInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTrainInput
  update: UserUpdateWithoutTrainDataInput
  upsert: UserUpsertWithoutTrainInput
}

input UserUpdateWithoutTrainDataInput {
  avatarId: String
  bio: String
  birthDate: DateTime
  classes: Int
  customerId: String
  email: String
  facebookId: String
  name: String
  password: String
  role: Role
  sex: Sex
  stripeId: String
  workouts: WorkoutUpdateManyWithoutPartecipantsInput
}

input UserUpdateWithoutWorkoutsDataInput {
  avatarId: String
  bio: String
  birthDate: DateTime
  classes: Int
  customerId: String
  email: String
  facebookId: String
  name: String
  password: String
  role: Role
  sex: Sex
  stripeId: String
  train: WorkoutUpdateManyWithoutTrainerInput
}

input UserUpdateWithWhereUniqueWithoutWorkoutsInput {
  data: UserUpdateWithoutWorkoutsDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutTrainInput {
  create: UserCreateWithoutTrainInput!
  update: UserUpdateWithoutTrainDataInput!
}

input UserUpsertWithWhereUniqueWithoutWorkoutsInput {
  create: UserCreateWithoutWorkoutsInput!
  update: UserUpdateWithoutWorkoutsDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  avatarId: NullableStringFilter
  bio: NullableStringFilter
  birthDate: NullableDateTimeFilter
  classes: IntFilter
  customerId: NullableStringFilter
  email: StringFilter
  facebookId: NullableStringFilter
  id: IntFilter
  name: NullableStringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  role: Role
  sex: Sex
  stripeId: NullableStringFilter
  train: WorkoutFilter
  workouts: WorkoutFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}

type Workout {
  cordinates: Cordinates!
  date: DateTime
  description: String
  duration: Int!
  id: Int!
  partecipants(skip: Int): [User!]!
  price: Int!
  spots: Int!
  title: String!
  trainer: User!
}

input WorkoutCreateManyWithoutCordinatesInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutCordinatesInput!]
}

input WorkoutCreateManyWithoutPartecipantsInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutPartecipantsInput!]
}

input WorkoutCreateManyWithoutTrainerInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutTrainerInput!]
}

input WorkoutCreateWithoutCordinatesInput {
  createdAt: DateTime
  date: DateTime
  description: String
  duration: Int!
  partecipants: UserCreateManyWithoutWorkoutsInput
  price: Int!
  spots: Int
  title: String!
  trainer: UserCreateOneWithoutTrainInput!
}

input WorkoutCreateWithoutPartecipantsInput {
  cordinates: CordinatesCreateOneWithoutWorkoutInput!
  createdAt: DateTime
  date: DateTime
  description: String
  duration: Int!
  price: Int!
  spots: Int
  title: String!
  trainer: UserCreateOneWithoutTrainInput!
}

input WorkoutCreateWithoutTrainerInput {
  cordinates: CordinatesCreateOneWithoutWorkoutInput!
  createdAt: DateTime
  date: DateTime
  description: String
  duration: Int!
  partecipants: UserCreateManyWithoutWorkoutsInput
  price: Int!
  spots: Int
  title: String!
}

input WorkoutFilter {
  every: WorkoutWhereInput
  none: WorkoutWhereInput
  some: WorkoutWhereInput
}

input WorkoutScalarWhereInput {
  AND: [WorkoutScalarWhereInput!]
  cordinatesId: IntFilter
  createdAt: DateTimeFilter
  date: NullableDateTimeFilter
  description: NullableStringFilter
  duration: IntFilter
  id: IntFilter
  NOT: [WorkoutScalarWhereInput!]
  OR: [WorkoutScalarWhereInput!]
  partecipants: UserFilter
  price: IntFilter
  spots: IntFilter
  title: StringFilter
  trainerId: IntFilter
}

input WorkoutUpdateInput {
  cordinates: CordinatesUpdateOneRequiredWithoutWorkoutInput
  createdAt: DateTime
  date: DateTime
  description: String
  duration: Int
  partecipants: UserUpdateManyWithoutWorkoutsInput
  price: Int
  spots: Int
  title: String
  trainer: UserUpdateOneRequiredWithoutTrainInput
}

input WorkoutUpdateManyDataInput {
  createdAt: DateTime
  date: DateTime
  description: String
  duration: Int
  price: Int
  spots: Int
  title: String
}

input WorkoutUpdateManyWithoutCordinatesInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutCordinatesInput!]
  delete: [WorkoutWhereUniqueInput!]
  deleteMany: [WorkoutScalarWhereInput!]
  disconnect: [WorkoutWhereUniqueInput!]
  set: [WorkoutWhereUniqueInput!]
  update: [WorkoutUpdateWithWhereUniqueWithoutCordinatesInput!]
  updateMany: [WorkoutUpdateManyWithWhereNestedInput!]
  upsert: [WorkoutUpsertWithWhereUniqueWithoutCordinatesInput!]
}

input WorkoutUpdateManyWithoutPartecipantsInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutPartecipantsInput!]
  delete: [WorkoutWhereUniqueInput!]
  deleteMany: [WorkoutScalarWhereInput!]
  disconnect: [WorkoutWhereUniqueInput!]
  set: [WorkoutWhereUniqueInput!]
  update: [WorkoutUpdateWithWhereUniqueWithoutPartecipantsInput!]
  updateMany: [WorkoutUpdateManyWithWhereNestedInput!]
  upsert: [WorkoutUpsertWithWhereUniqueWithoutPartecipantsInput!]
}

input WorkoutUpdateManyWithoutTrainerInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutTrainerInput!]
  delete: [WorkoutWhereUniqueInput!]
  deleteMany: [WorkoutScalarWhereInput!]
  disconnect: [WorkoutWhereUniqueInput!]
  set: [WorkoutWhereUniqueInput!]
  update: [WorkoutUpdateWithWhereUniqueWithoutTrainerInput!]
  updateMany: [WorkoutUpdateManyWithWhereNestedInput!]
  upsert: [WorkoutUpsertWithWhereUniqueWithoutTrainerInput!]
}

input WorkoutUpdateManyWithWhereNestedInput {
  data: WorkoutUpdateManyDataInput!
  where: WorkoutScalarWhereInput!
}

input WorkoutUpdateWithoutCordinatesDataInput {
  createdAt: DateTime
  date: DateTime
  description: String
  duration: Int
  partecipants: UserUpdateManyWithoutWorkoutsInput
  price: Int
  spots: Int
  title: String
  trainer: UserUpdateOneRequiredWithoutTrainInput
}

input WorkoutUpdateWithoutPartecipantsDataInput {
  cordinates: CordinatesUpdateOneRequiredWithoutWorkoutInput
  createdAt: DateTime
  date: DateTime
  description: String
  duration: Int
  price: Int
  spots: Int
  title: String
  trainer: UserUpdateOneRequiredWithoutTrainInput
}

input WorkoutUpdateWithoutTrainerDataInput {
  cordinates: CordinatesUpdateOneRequiredWithoutWorkoutInput
  createdAt: DateTime
  date: DateTime
  description: String
  duration: Int
  partecipants: UserUpdateManyWithoutWorkoutsInput
  price: Int
  spots: Int
  title: String
}

input WorkoutUpdateWithWhereUniqueWithoutCordinatesInput {
  data: WorkoutUpdateWithoutCordinatesDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutUpdateWithWhereUniqueWithoutPartecipantsInput {
  data: WorkoutUpdateWithoutPartecipantsDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutUpdateWithWhereUniqueWithoutTrainerInput {
  data: WorkoutUpdateWithoutTrainerDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutUpsertWithWhereUniqueWithoutCordinatesInput {
  create: WorkoutCreateWithoutCordinatesInput!
  update: WorkoutUpdateWithoutCordinatesDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutUpsertWithWhereUniqueWithoutPartecipantsInput {
  create: WorkoutCreateWithoutPartecipantsInput!
  update: WorkoutUpdateWithoutPartecipantsDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutUpsertWithWhereUniqueWithoutTrainerInput {
  create: WorkoutCreateWithoutTrainerInput!
  update: WorkoutUpdateWithoutTrainerDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutWhereInput {
  AND: [WorkoutWhereInput!]
  cordinates: CordinatesWhereInput
  cordinatesId: IntFilter
  createdAt: DateTimeFilter
  date: NullableDateTimeFilter
  description: NullableStringFilter
  duration: IntFilter
  id: IntFilter
  NOT: [WorkoutWhereInput!]
  OR: [WorkoutWhereInput!]
  partecipants: UserFilter
  price: IntFilter
  spots: IntFilter
  title: StringFilter
  trainer: UserWhereInput
  trainerId: IntFilter
}

input WorkoutWhereUniqueInput {
  id: Int
}
