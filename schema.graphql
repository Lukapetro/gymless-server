### This file was generated by Nexus Schema
### Do not make changes to this file directly


type AuthPayload {
  token: String!
  user: User!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Mutation {
  bookWorkout(id: ID): Workout!
  createOneWorkout(data: WorkoutCreateInput!): Workout!
  createWorkout(date: DateTime, description: String, location: String, spots: Int, title: String): Workout!
  deleteBooking(id: ID): Workout!
  deleteOneWorkout(where: WorkoutWhereUniqueInput!): Workout
  facebookLogin(fbToken: String!): AuthPayload!
  login(email: String!, password: String!): AuthPayload!
  paymentIntent: String!
  signup(email: String!, name: String, password: String!): AuthPayload!
  trainerLogin(email: String!, password: String!): AuthPayload!
  updateOneWorkout(data: WorkoutUpdateInput!, where: WorkoutWhereUniqueInput!): Workout
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Query {
  getAvailableWorkouts: [Workout!]!
  me: User!
  workout(where: WorkoutWhereUniqueInput!): Workout
  workouts(skip: Int, where: WorkoutWhereInput): [Workout!]!
  workoutsBooked: [Workout!]!
}

enum Role {
  admin
  trainer
  user
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  email: String!
  id: Int!
  name: String
  role: Role!
  stripeId: String
  workouts(skip: Int): [Workout!]!
}

input UserCreateManyWithoutWorkoutsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutWorkoutsInput!]
}

input UserCreateOneWithoutTrainInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTrainInput
}

input UserCreateWithoutTrainInput {
  email: String!
  facebookId: String
  name: String
  password: String!
  role: Role
  stripeId: String
  workouts: WorkoutCreateManyWithoutPartecipantsInput
}

input UserCreateWithoutWorkoutsInput {
  email: String!
  facebookId: String
  name: String
  password: String!
  role: Role
  stripeId: String
  train: WorkoutCreateManyWithoutTrainerInput
}

input UserFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserScalarWhereInput {
  AND: [UserScalarWhereInput!]
  email: StringFilter
  facebookId: NullableStringFilter
  id: IntFilter
  name: NullableStringFilter
  NOT: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  password: StringFilter
  role: Role
  stripeId: NullableStringFilter
  train: WorkoutFilter
  workouts: WorkoutFilter
}

input UserUpdateManyDataInput {
  email: String
  facebookId: String
  name: String
  password: String
  role: Role
  stripeId: String
}

input UserUpdateManyWithoutWorkoutsInput {
  connect: [UserWhereUniqueInput!]
  create: [UserCreateWithoutWorkoutsInput!]
  delete: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  disconnect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutWorkoutsInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutWorkoutsInput!]
}

input UserUpdateManyWithWhereNestedInput {
  data: UserUpdateManyDataInput!
  where: UserScalarWhereInput!
}

input UserUpdateOneRequiredWithoutTrainInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTrainInput
  update: UserUpdateWithoutTrainDataInput
  upsert: UserUpsertWithoutTrainInput
}

input UserUpdateWithoutTrainDataInput {
  email: String
  facebookId: String
  name: String
  password: String
  role: Role
  stripeId: String
  workouts: WorkoutUpdateManyWithoutPartecipantsInput
}

input UserUpdateWithoutWorkoutsDataInput {
  email: String
  facebookId: String
  name: String
  password: String
  role: Role
  stripeId: String
  train: WorkoutUpdateManyWithoutTrainerInput
}

input UserUpdateWithWhereUniqueWithoutWorkoutsInput {
  data: UserUpdateWithoutWorkoutsDataInput!
  where: UserWhereUniqueInput!
}

input UserUpsertWithoutTrainInput {
  create: UserCreateWithoutTrainInput!
  update: UserUpdateWithoutTrainDataInput!
}

input UserUpsertWithWhereUniqueWithoutWorkoutsInput {
  create: UserCreateWithoutWorkoutsInput!
  update: UserUpdateWithoutWorkoutsDataInput!
  where: UserWhereUniqueInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  email: StringFilter
  facebookId: NullableStringFilter
  id: IntFilter
  name: NullableStringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  role: Role
  stripeId: NullableStringFilter
  train: WorkoutFilter
  workouts: WorkoutFilter
}

input UserWhereUniqueInput {
  email: String
  id: Int
}

type Workout {
  date: DateTime
  description: String
  id: Int!
  location: String
  partecipants(skip: Int): [User!]!
  spots: Int!
  title: String!
  trainer: User!
}

input WorkoutCreateInput {
  createdAt: DateTime
  date: DateTime
  description: String
  location: String
  partecipants: UserCreateManyWithoutWorkoutsInput
  spots: Int
  title: String!
  trainer: UserCreateOneWithoutTrainInput!
}

input WorkoutCreateManyWithoutPartecipantsInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutPartecipantsInput!]
}

input WorkoutCreateManyWithoutTrainerInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutTrainerInput!]
}

input WorkoutCreateWithoutPartecipantsInput {
  createdAt: DateTime
  date: DateTime
  description: String
  location: String
  spots: Int
  title: String!
  trainer: UserCreateOneWithoutTrainInput!
}

input WorkoutCreateWithoutTrainerInput {
  createdAt: DateTime
  date: DateTime
  description: String
  location: String
  partecipants: UserCreateManyWithoutWorkoutsInput
  spots: Int
  title: String!
}

input WorkoutFilter {
  every: WorkoutWhereInput
  none: WorkoutWhereInput
  some: WorkoutWhereInput
}

input WorkoutScalarWhereInput {
  AND: [WorkoutScalarWhereInput!]
  createdAt: DateTimeFilter
  date: NullableDateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  location: NullableStringFilter
  NOT: [WorkoutScalarWhereInput!]
  OR: [WorkoutScalarWhereInput!]
  partecipants: UserFilter
  spots: IntFilter
  title: StringFilter
  trainerId: IntFilter
}

input WorkoutUpdateInput {
  createdAt: DateTime
  date: DateTime
  description: String
  location: String
  partecipants: UserUpdateManyWithoutWorkoutsInput
  spots: Int
  title: String
  trainer: UserUpdateOneRequiredWithoutTrainInput
}

input WorkoutUpdateManyDataInput {
  createdAt: DateTime
  date: DateTime
  description: String
  location: String
  spots: Int
  title: String
}

input WorkoutUpdateManyWithoutPartecipantsInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutPartecipantsInput!]
  delete: [WorkoutWhereUniqueInput!]
  deleteMany: [WorkoutScalarWhereInput!]
  disconnect: [WorkoutWhereUniqueInput!]
  set: [WorkoutWhereUniqueInput!]
  update: [WorkoutUpdateWithWhereUniqueWithoutPartecipantsInput!]
  updateMany: [WorkoutUpdateManyWithWhereNestedInput!]
  upsert: [WorkoutUpsertWithWhereUniqueWithoutPartecipantsInput!]
}

input WorkoutUpdateManyWithoutTrainerInput {
  connect: [WorkoutWhereUniqueInput!]
  create: [WorkoutCreateWithoutTrainerInput!]
  delete: [WorkoutWhereUniqueInput!]
  deleteMany: [WorkoutScalarWhereInput!]
  disconnect: [WorkoutWhereUniqueInput!]
  set: [WorkoutWhereUniqueInput!]
  update: [WorkoutUpdateWithWhereUniqueWithoutTrainerInput!]
  updateMany: [WorkoutUpdateManyWithWhereNestedInput!]
  upsert: [WorkoutUpsertWithWhereUniqueWithoutTrainerInput!]
}

input WorkoutUpdateManyWithWhereNestedInput {
  data: WorkoutUpdateManyDataInput!
  where: WorkoutScalarWhereInput!
}

input WorkoutUpdateWithoutPartecipantsDataInput {
  createdAt: DateTime
  date: DateTime
  description: String
  location: String
  spots: Int
  title: String
  trainer: UserUpdateOneRequiredWithoutTrainInput
}

input WorkoutUpdateWithoutTrainerDataInput {
  createdAt: DateTime
  date: DateTime
  description: String
  location: String
  partecipants: UserUpdateManyWithoutWorkoutsInput
  spots: Int
  title: String
}

input WorkoutUpdateWithWhereUniqueWithoutPartecipantsInput {
  data: WorkoutUpdateWithoutPartecipantsDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutUpdateWithWhereUniqueWithoutTrainerInput {
  data: WorkoutUpdateWithoutTrainerDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutUpsertWithWhereUniqueWithoutPartecipantsInput {
  create: WorkoutCreateWithoutPartecipantsInput!
  update: WorkoutUpdateWithoutPartecipantsDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutUpsertWithWhereUniqueWithoutTrainerInput {
  create: WorkoutCreateWithoutTrainerInput!
  update: WorkoutUpdateWithoutTrainerDataInput!
  where: WorkoutWhereUniqueInput!
}

input WorkoutWhereInput {
  AND: [WorkoutWhereInput!]
  createdAt: DateTimeFilter
  date: NullableDateTimeFilter
  description: NullableStringFilter
  id: IntFilter
  location: NullableStringFilter
  NOT: [WorkoutWhereInput!]
  OR: [WorkoutWhereInput!]
  partecipants: UserFilter
  spots: IntFilter
  title: StringFilter
  trainer: UserWhereInput
  trainerId: IntFilter
}

input WorkoutWhereUniqueInput {
  id: Int
}
